# -*- coding: utf-8 -*-
"""ADS Exp 4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yaJIaRKg5KFRtwvrZdr8TXYFn5UntP-Y
"""

import pandas as pd
df = pd.read_csv("ADS_dataset.csv")
df.head()

df.dropna(inplace=True)
df.head()

df = df.fillna(df.mean())
df.head(30)

df.describe()

df.drop(['Date', 'Location', 'WindGustDir', 'WindDir9am', 'WindDir3pm', 'RainTomorrow'], axis='columns', inplace=True)
df['RainToday'] = df['RainToday'].fillna('No')
df.head()

#encoding
df.RainToday = df.RainToday.map({'Yes': 1, 'No': 0})
df.head()

inputs = df.drop('RainToday',axis='columns')
inputs.head()

from sklearn.preprocessing import MinMaxScaler

#normalize
scaler = MinMaxScaler()
scaler.fit(inputs)
df_normalized = pd.DataFrame(scaler.transform(inputs), columns=inputs.columns)
df_normalized.head()

target = df.RainToday
target.head()

"""# **Classification**"""

from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.neighbors import KNeighborsClassifier

X_train, X_test, y_train, y_test = train_test_split(df_normalized, target, test_size=0.3)

# clf = DecisionTreeClassifier()
clf = KNeighborsClassifier()
clf.fit(X_train, y_train)
y_pred = clf.predict(X_test)

"""**Confusion Matrix**"""

from sklearn.metrics import confusion_matrix  
cm= confusion_matrix(y_test, y_pred) 
print(cm)

"""**Accuracy**"""

from sklearn.metrics import accuracy_score
accuracy = accuracy_score(y_test, y_pred)
print("Accuracy:", accuracy)

"""**Error Rate**"""

error_rate = 1 - accuracy
print("Error rate:", error_rate)

"""**Precision**"""

from sklearn.metrics import precision_score
precision = precision_score(y_test, y_pred)
print("Precision:", precision)

"""**Sensitivity, Recall, Power**"""

from sklearn.metrics import classification_report
tn, fp, fn, tp = confusion_matrix(y_test, y_pred).ravel()
sensitivity = tp / (tp + fn)
print("Sensitivity, Recall, Power:", sensitivity)

"""**Specificity**"""

specificity = tn / (tn + fp)
print("Specificity:", specificity)

"""**ROC**"""

from sklearn.metrics import roc_auc_score
roc_auc = roc_auc_score(y_test, y_pred)
print("ROC AUC Score:", roc_auc)

"""**F1 Score**"""

from sklearn.metrics import f1_score
f1 = f1_score(y_test, y_pred)
print("F1 Score:", f1)

"""**Geometric mean**"""

import math
geometric_mean = math.sqrt(sensitivity*specificity)
print("Geometric mean: ", geometric_mean)

"""**False Positive Rate**"""

print("False Positive Rate: ", 1-specificity)

"""**False Negative Rate**"""

print("False Negative Rate: ", 1-sensitivity)

"""**ROC Curve**"""

from sklearn.metrics import roc_curve
import matplotlib.pyplot as plt

fpr, tpr, thresholds = roc_curve(y_test, y_pred)

plt.plot(fpr, tpr)
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Curve')
plt.show()

"""# **Regression**"""

X = df_normalized.MinTemp
Y = df_normalized.MaxTemp

"""**Karl pearson's coefficient of correlation**"""

from scipy.stats import pearsonr
corr, _ = pearsonr(X, Y)
print("Karl Pearson's coefficient of correlation:", corr)

"""**Coefficient of Determination(R-squared)**"""

from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score
reg = LinearRegression()

X = X.values
X = X.reshape(-1, 1)

reg.fit(X, Y)
y_pred = reg.predict(X)
r_squared = r2_score(Y, y_pred)
print("R-squared:", r_squared)

"""**Mean squared error**"""

from sklearn.metrics import mean_squared_error
mse = mean_squared_error(Y, y_pred)
print("Mean Squared Error:", mse)

"""**Root mean squared error**"""

rmse = math.sqrt(mse)
print("RMSE:", rmse)

"""**Root mean squared relative error**"""

import numpy as np
num = np.sum(np.square(Y - y_pred))
den = np.sum(np.square(y_pred))
n = Y.shape[0]
squared_error = num/(n*den)
rmsre = np.sqrt(squared_error)
print("RMSRE:",rmsre)

"""**Mean Absolute error**"""

from sklearn.metrics import mean_absolute_error
mae = mean_absolute_error(Y, y_pred)
print("MAE:", mae)

"""**Mean Absolute Percentage error**"""

mape = np.mean(np.abs((Y - y_pred) / Y)) * 100
print("MAPE:", mape, end="%")